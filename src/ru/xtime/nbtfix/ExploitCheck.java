package ru.xtime.nbtfix;

import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.bukkit.Material;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import com.comphenix.protocol.wrappers.nbt.NbtBase;
import com.comphenix.protocol.wrappers.nbt.NbtCompound;
import com.comphenix.protocol.wrappers.nbt.NbtFactory;
import com.comphenix.protocol.wrappers.nbt.NbtList;
import com.google.common.io.BaseEncoding;

public class ExploitCheck {
    private Boolean removeInvalidEnch;
    private Boolean checkench;
    private HashSet<String> worlds = new HashSet<String>();
    private HashSet<String> nbt = new HashSet<String>();
    private HashSet<String> eggs = new HashSet<String>();
    private HashSet<String> armor = new HashSet<String>();
    private HashSet<String> book = new HashSet<String>();
    private HashSet<String> inventory = new HashSet<String>();
    private HashSet<Material> material = new HashSet<Material>();
    private Main plugin;

    public ExploitCheck(Main main) {
        this.plugin = main;
    }
    public void fillLists() {
        nbt.clear();
        eggs.clear();
        armor.clear();
        book.clear();
        inventory.clear();
        material.clear();
        List<String> world = plugin.getConfig().getStringList("ignore-worlds");
        for (String w : world) {
            worlds.add(w.toLowerCase());
        }
        checkench = plugin.getConfig().getBoolean("check-enchants");
        removeInvalidEnch = plugin.getConfig().getBoolean("remove-invalid-enchants");
        nbt.addAll(plugin.getConfig().getStringList("nbt"));
        eggs.addAll(plugin.getConfig().getStringList("spawneggs"));
        if (!eggs.contains("Size")) eggs.add("Size");
        armor.addAll(plugin.getConfig().getStringList("armorstand"));
        book.addAll(plugin.getConfig().getStringList("writtenbook"));
        inventory.addAll(plugin.getConfig().getStringList("inventory"));
        material.add(Material.FURNACE);
        material.add(Material.CHEST);
        material.add(Material.TRAPPED_CHEST);
        material.add(Material.DROPPER);
        material.add(Material.DISPENSER);
        material.add(Material.COMMAND);
        material.add(Material.COMMAND_MINECART);
        material.add(Material.HOPPER);
        material.add(Material.HOPPER_MINECART);
        material.add(Material.BREWING_STAND);
        material.add(Material.BREWING_STAND_ITEM);
        material.add(Material.BEACON);
    }
    /* Skull Exploit Fix Code
     * https://github.com/MylesIsCool/SkullExploitPatch
     * https://www.spigotmc.org/resources/skull-exploit-fix.26099/
     */
    @SuppressWarnings("rawtypes")
    public boolean isExploitSkull(NbtCompound root) {
        // Item
        if (root.containsKey("SkullOwner")) {
            NbtCompound skullOwner = root.getCompound("SkullOwner");
            if (skullOwner.containsKey("Properties")) {
                NbtCompound properties = skullOwner.getCompound("Properties");
                if (properties.containsKey("textures")) {
                    NbtList<NbtBase> textures = properties.getList("textures");
                    for (NbtBase texture : textures.asCollection()) {
                        if (texture instanceof NbtCompound) {
                            // Check for value
                            if (((NbtCompound) texture).containsKey("Value")) {
                                if (((NbtCompound) texture).getString("Value").trim().length() > 0) {
                                    String decoded = new String(BaseEncoding.base64().decode(((NbtCompound) texture).getString("Value")));
                                    if (decoded.contains("textures") && decoded.contains("SKIN")) {
                                        if (decoded.contains("url")) {
                                            String Url = decoded.split("url")[1].replace("\"", "").replace(":", "").replace("{", "").replace("}", "");
                                            if (Url.trim().length() == 0) {
                                                root.remove("SkullOwner");
                                                return true;
                                            }
                                        } else {
                                            root.remove("SkullOwner");
                                            return true;
                                        }
                                    } else {
                                        root.remove("SkullOwner");
                                        return true;
                                    }
                                } else {
                                    root.remove("SkullOwner");
                                    return true;
                                }
                            } else {
                                root.remove("SkullOwner");
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
    //
    private ItemMeta getClearMeta(ItemStack stack) {
        final ItemMeta meta = stack.getItemMeta();
        for (Map.Entry<Enchantment, Integer> ench : meta.getEnchants().entrySet()) {
            Enchantment Enchant = ench.getKey();
            if (removeInvalidEnch && !Enchant.canEnchantItem(stack) ) {
                meta.removeEnchant(Enchant);
            }
            if (ench.getValue() > Enchant.getMaxLevel() || ench.getValue() < 0) {
                meta.removeEnchant(Enchant);
            }
        }
        return meta;
    }
    public boolean isExploit(ItemStack stack, String world) {
        if (worlds.contains(world)) return false;
        boolean b = false;
        if (stack == null || stack.getType() == Material.AIR) return false;
        if (stack.getType() == Material.matchMaterial("STRUCTURE_BLOCK")) {
            return true;
        }
        try {
            Material mat = stack.getType();
            NbtCompound tag = (NbtCompound) NbtFactory.fromItemTag(stack);
            if(stack.getAmount()<1 || stack.getAmount()>64) {
                stack.setAmount(1);
                tag.getKeys().clear();
                return true;
            }
            //CrashChest. CrashItem.
            if (mat == Material.ENDER_PEARL || mat == Material.SNOW_BALL || mat == Material.CHEST || mat == Material.NAME_TAG || mat == Material.TRAPPED_CHEST) {
                String tags = tag.toString();
                if (tags.length() > 400 || tags.contains("NaNd")) {
                    tag.getKeys().clear();
                    return true;
                }
            }
            //
            for (String a : nbt) {
                if (tag.containsKey(a)) {
                    tag.remove(a);
                    b = true;
                }
            }
            if (material.contains(mat)) {
                for (String a : inventory) {
                    if (tag.containsKey(a)) {
                        tag.remove(a);
                        b = true;
                    }
                }
            } else if (mat == Material.WRITTEN_BOOK) {
                final String c = tag.toString();
                for (String a : book) {
                    if (c.contains(a)) {
                        tag.getKeys().clear();
                        b = true;  
                    }
                }
            } else if (mat == Material.MONSTER_EGG) {
                final String c = tag.toString();
                for (String a : eggs) {
                    if (c.contains(a)) {
                        tag.getKeys().clear();
                        b = true;
                    }
                }
            } else if (mat == Material.matchMaterial("ARMOR_STAND")) {
                for (String a : armor) {
                    if (tag.containsKey(a)) {
                        tag.remove(a);
                        b = true;
                    }
                }
            } else if ((mat == Material.SKULL || mat == Material.SKULL_ITEM) && stack.getDurability() == 3) {
                if (isExploitSkull(tag)) b = true;
            }
        } catch (Exception e) {
            if (checkench && stack.hasItemMeta() && stack.getItemMeta().hasEnchants()) {
                stack.setItemMeta(getClearMeta(stack));
            }
            return b;
        }
        if (checkench && stack.hasItemMeta() && stack.getItemMeta().hasEnchants()) {
            stack.setItemMeta(getClearMeta(stack));
        }
        return b;
    }
}
